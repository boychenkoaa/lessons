1. Ситуация аналогична примеру из материала урока
if not (0.0001 < slice_height < 1000):
    raise ValueError

я решил вывести эту штуку в 

max_slice_height():
	return 1000
	
min_slice_height():
	return 1e-4
	
в будущем планирую эту константу вынести в конфигурационный файл для возможности настройки квалифицированным пользователем

поэтому подобная гибкость оправдана

if not (min_slice_height() <= slice_height <= max_slice_height()):
    raise ValueError


2.
Правка 11 из предыдущего задания

Коллега вписал единичную матрицу в локальные переменные

identity_matrix = np.array([[1., 0., 0., 0.],
                                    [0., 1., 0., 0.],
                                    [0., 0., 1., 0.],
                                    [0., 0., 0., 1.]])

Это точно не локальная переменная, да и меняться она не может.

ID4_MATRIX = np.array  ([[1., 0., 0., 0.],
						[0., 1., 0., 0.],
                        [0., 0., 1., 0.],
                        [0., 0., 0., 1.]])
						
Из локальной переменной повышена до глобальной, на уровне модуля.

В других модулях работы с матрицами трансформации не предусмотрено, поэтому такого повышения достаточно

3. 
Эпсилон-допуск для алгоритмов вычислительной геометрии
изначально он был один во всех классах
была глобальная переменная EPSILON
и все классы брали ее оттуда

При рефакторинге и тестах я все же пришел к тому что это слишком жесткая схема

В каждый класс, связанный с алгоритмами, использующими эпсилон, задаем его собственный и делаем его по умолчанию равным глобальной переменной

пример
# интерфейс
class CollisionDetector():
	def __init__(self, epsilon = EPSILON):
		self._epsilon = epsilon



