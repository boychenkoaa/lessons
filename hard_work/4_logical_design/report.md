Мы продолжаем переписывать аддон к компасу (3 участка кода -- GUI, обращения к API (но с ними встал вопрос шире) и нижний уровень, где геометрия не-компаса).

## Часть 1. Декларативный GUI

*наверное это самый подходящий к заданию кусок кода*

**Дизайн (было и стало)**: 

![изображение](https://github.com/user-attachments/assets/ac5ca3fd-b329-4542-8089-477ae157b53f)

GUI окно с вложенными вкладками, каждая вкладка -- набор "строк", каждая строка делает какую-то одну функцию.
Типы строк: 
- поле ввода (слева и справа -- метки),
- кнопка,
- ряд кнопок,
- строка текста (заголовок),
- подсказка (строка текста уменьшенного размера и курсивом).
Требования: внешний вид не важен, быстрая модификация и привязка к строкам-переменным и командам.

GUI может наполняться быстро, но на коленке, и довольно криво, ненужные параметры в функциях и т д.
Хочеться убрать мишуру и сделать размещение элементов на окне декларативным. Я знаю про языки типа QML b Qt.

Старый код: 
- [gui_base_old.py](gui_base_old.py)
- [gui_main_old.py](gui_main_old.py)

Новый код (ООП + декларативный подход): [gui_new.py](gui_new.py)

**Стало - дизайн**

- получилась кривая (но декларативная) реализация этакого тривиального микро-языка разметки для моего случая (метод config класса WaamGUI).
- Теперь конфигурация GUI задается явно, все лишнее убрано, команды собраны в одном месте. 
- Радикальных изменений в GUI не будет, но кажется я понял, как можно добавить панель с кнопками и менять ее содержимое.
Я знаю про Qt и QML, но мне это показалось избыточным для такого простого (по крайней мере, с виду) аддона...

**Стало - классы**

было: классов не было
стало: 
- `ksNotebookWindow` -- класс моего окна
- `WaamGUI` -- общий класс приложения, команды оборачивают методы `WaamAPP` (о нем ниже)
- вспомогательные классы для "линий" Gui -- `GuiEntryLine`, `GuiTextLine` и т д

## Часть 2. Работа с пространством модели компаса. Аддон в целом.

**Было - дизайн**
- пользователю нужны команды для редактирования геометрии (CAD) и редактирования свойств траекторий (CAM)
- иерархия классов не определена (можно делать сколь угодно запутанно, лишь бы были методы, которые прямо вызываются из GUI)
- настройки программы хранятся в глобальных переменных
  команды GUI вызывают какие-то методы из неважно, каких классов (то бишь у клубка указано, за какие ниточки его можно дергать. Аргументы берутся из настроек - глобальных переменных), но не более
- вспомогательные методы делались по необходимости по ходу пьесы, и не имеют каких-то критериев, кроме DRY

**Было -- классы** 
- команды редактирования разделены по принципу 2d/3d (неудобно) -- классы 'Manipulator2d' / 'Manipulator3d'
- команды манипуляций с траекториями отнесены к 2д (неудобно, так вышло)
- "состояние приложения" собрано в отдельный модуль, но не в отдельный класс 

_Файлы_
[doc2d.py](doc2d.py)
[doc3d.py](doc3d.py)
[global_var.py](global_var.py)

**Стало -- дизайн**

Делаем дизайн строже
- 5 уровней логики
	1. GUI 
  2. обработчики событий -- обертки команд пользовательских функций
	3. команды CAD/CAM
	- обертки над командами и запросами к API конвертация геометрии
	- алгоритмы над геометрией (CAD) либо работа с буфером (CAM)
	- разделение команд по назначению (CAD, CAM). Каждая команда CAD это (наиболее сложный случай, некоторые шаги могут быть пропущены)
		1. предобработка входных данных (возможно, средствами запросов API)
		2. обертка над запросом к API к модельному пространству, 
		3. конвертация в свой тип геометрии
		4. алгоритм свой
    5. обратная конвертация и обертка над командой API для добавления
	- команды CAM это либо манипуляции над буфером (изменение порядка, удаление), либо постпроцессинг либо добавление в буфер:
		1. предобработка входных данных
		2. обертка над запросом к API к модельному пространству
		3. конвертация в траекторию в зависимости от типа интерпретатора (одна и та же геометрия, вообще говоря, может быть интерпретирована не единственным способом)
		4. добавление траектории в буфер
	- CAM также включает в себя либо постпроцессинг и выдачу УП, постпроцессор можно задать любой, постпроцессор имеет собственные настройки.

  4. составляющие части уровня 3, объединенные в классы (обертки над командами API, обертки над запросами API, конвертация геометрии / конвертация геометрии в траекторию)
  5. алгоритмы, классы геометрии / траектории и их группы и алгоритмы над ними, операции над буфером, экспорт
- состояние приложения (условные "глобальные переменные"):
  - настройки траектории (постоянные и временные)
  - настройки УП (вообще, должны быть отдельные классы настроек для каждого типа интерпретатора траекторий -- этого пока нет)
  - настройки экспорта (путь к сохранению файлов, тип постпроцессора, настройки постпроцессора)
  - настройки алгоритмов по умолчанию (не реализовано)
  - тип постпроцессора и интерпретатора

**Cтало -- классы**

- `CAD` команды реализуются классом `ksCAD`
- `CAM` команды классом `ksCAM`
- команды чтения используются  и там и там и вынесены в отдельный класс `Reader`
- аналогично алгоритмы конвертации классов компаса в свои геометрию (`ksConverter`) - нужны и там и там
- конвертер можно реализовать декларативно (кучу методов на разные типы геометрии) и один базовый метод `convert` и таблица соответствия
- класс `ksWaamApp` -- фасад над всеми перечисленными + хранит состояние
- состояние это
  - настройки это датаклассы `PathSettings`, `JobSettings`, `PostProcessor`, `Interpreter` а также
  - класс `JOB` (текущий буфер с траекториями)как обертка над упорядоченным списком траекторий (реализован в других модулях)
  - класс `Interpreter` преобразует геометрию в класс `RobotPath` 

Файлы
[editor2d.py](editor2d.py)


## Часть 3. Геометрия
Это уже на сдачу от предыдущих двух.

**Было - дизайн**
Процедурный стиль, как будто фортран.
Из алгоритмов только змейка, геометрические типы второстепенные и вспомогательные, своих классов нет. 
Все преобразования (повороты, сдвиги, и пр), простые алгоритмы типа поиска пересечений и пр -- исключительно процедурами, все на списках и кортежах. 
Это быстро для небольшого объема вычислений и резко усложняется при возрастающих требованиях (дуги и пр).

**Было - классы**
Классов как таковых не было, все на списках и кортежах. Процедурный стиль программирования.

_Файлы_
- [geom2d_base.py](geom2d_base.py)
- [geom_raw_old.py](geom_raw_old.py)



**Стало - дизайн**
Меняем процедурный стиль на ООП.
Для возможности интерпретировать дуги как вращение позиционера уже сложно обходиться только линейной геометрией и дуга понадобилась уже не в виде списка из трех точек, а в виде отдельного класса.
Соответственно, отрезки, контуры, окружности и полилинии стали тоже классами.
Стало возможным интерпретировать дуги как вращение позиционера, а также проще строить алгоритмы над геометрией (реверс, смещение, змейки, спирали, упорядочивание).
Кроме того, становится более общепринятыми геометрические вычисления -- в частности, задача пересечения двух отрезков, принадлежности точки отрезку, коллинеарности векторов и т д будут сводиться к предикату "левый поворот", который, в свою очередь, при необходимости, может быть вычислен интервальной либо длинной арифметикой точнее, чем обычной арифметикой.

**Стало - классы.**
Сами классы `Arc2`, `Segment2`, `Pline2` простые и скучные, ничего выдающегося. Пример метода -- вычисление радиуса дуги по трем точкам. Методы конвертации в старые форматы остались (`raw`) на всякий случай.

_Файлы_
- [geom2d.py](geom2d.py)
- [geom_raw.py](geom_raw.py)
