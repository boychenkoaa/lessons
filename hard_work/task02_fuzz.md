Если кратко -- фаззинг вызвал целый шквал мыслей, из которых вопросов пока больше чем ответов.

Вводные
1. Тестируем проект `kompas_slicer` (3000 строк, назначение -- плагин на `Python` для Компас-3D который слайсит модель, заполняет слои и выгружает траектории). Особенностью проекта является активная работа с [Компас3D-SDK](https://help.ascon.ru/KOMPAS_SDK/22/ru-RU/index.html) 
2. Из фаззеров используем [Hyphothesis](https://hypothesis.readthedocs.io/en/latest/), он показался наиболее гибким и интересным.
3.  Первым делом тестируем собственные геометрические классы (файлы `geom_raw.py` -- "обычная" геометрия и `points1.py` -- класс для точек поиском ближайшей точки за амортизированное `О(1)` время ) математику. 
	1. Для них проще всего описать входные данные.
	2. Для более "высокоуровневых" классов нужно моделировать сценарий использования, кроме того, для корректной работы оберток-классов компаса -- нужен запущенный Компас во время тестирования. 

Типовые ошибки и неудобства
1. Разумеется, россыпь ошибок на границах области определения простых математических функций (`NaN`, бесконечности, нули, очень большие значения, очень маленькие значения, деление на 0) в каждой функции, без исключения :-\
2. Вольности при определении типов в духе `Point23 = Point2 | Point3` при вызове функций типа `distance(point1: Point23, point2: Point23)` приводили к ошибкам из-за разной размерности точек (первая 2 вторая 3 или наоборот).
3. Не самое маленькое время тестирования (минимум 2-3 секунды на четырехядерном процессоре на функцию)
4. Для генерации классов компаса нужно постоянно обращаться через COM к его ядру, что тоже не добавляет производительности.

Рефлексия, выводы. 
1. Фаззинг-тестирование стимулирует к четкому задания области определения и области значений всех функций и методов.
2. Если система типов плохо проработана, как в моем случае, фаззинг отнимает изрядное количество времени (как написание тестов, так и собственно исполнение).
3. Главная проблема -- совсем не ясно, как учитывать эти ограничения и делать валидацию параметров на уровне проектирования системы. Неужели придется делать на каждое ограничение свой подтип? Только для `float`-параметров и только в  функциях модуля `geom_raw` я насчитал четыре области определения -- не ноль, больше `0`, от `0` до `1`, от `1e-5` до `1e7` .  Динамическая типизация (на мой взгляд) противоречит этой идее: если мы хотим так строго определять типы и контролировать их, зачем используем `Python`?
4. Каждый класс, при такой подробной спецификации, задан в общем случае подмножеством множества комбинаций допустимых значений всех атрибутов. И это именно подмножество -- в общем случае атрибуты могут зависеть друг от друга (хоть это и нехорошо). Соответственно, при проектировании класса надо иметь механизм контроля и учета этих зависимостей.
5. Если  делать отдельную иерархию классов-валидаторов -- не будет ли это перепроектированием и преждевременной оптимизацией, которая корень всех бед? Аналогичный вопрос для "внутренней" рефлексии класса и самопроверки.
6. Классы ядра компаса нужно продублировать упрощенными версиями своих. (И соответственно, написать конвертеры). Тогда подключенный компас понадобится только для конвертеров.
7. Нужно изучить stateful-тестирование класса (hypothesis такое также позволяет, и это очень интересно, например, при переходах из состояния в состояние проверяются утверждения, помеченные декоратором @invariant).
8. Также нужно изучить обязательно пакеты-аддоны `hypothesis-auto` для быстрого тестирования и `hypothesis-geometry` для генерации геометрических данных (их я случайно обнаружил буквально сегодня, в день написания отчета, попробовать не успел). Генерация корректной геометрии это отдельная проблема, например, чтобы полилинии не самопересекались или отверстия в полигоне не выходили за внешний контур.
