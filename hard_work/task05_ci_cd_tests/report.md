### Общее впечатление
Задание далось почему-то с сильным скрипом, я никак не мог взять в толк, как это -- удалять нерабочий код, если он не прошел тест. 
Немного похоже на метод решения сложных задач по математике: если не получается с наскока решить в общем виде, то сначала рассматриваем простые случаи, ищем закономерности, потом обобщаем.

1. Когда пишем новый код, можно коммитить раз в день или раз в один модуль -- выбираем сами "шаг", по настроению и сложности и квалификации
2. Когда правим код от которого зависят другие модули, коммитим малейшие изменения при пройденных тестах
3. Минимальным шагом может быть
	1. логический блок большой функции / метода (тогда тесты могут проверять промежуточные состояния вычисления, которые временно делаются возвращаемыми)
	2. функция / метод
	3. класс целиком
	4. модуль целиком
4. Выбираем минимальный шаг исходя из квалификации и особенностей мышления конкретного программиста, субъективных ощущений -- идет/не идет. Для простых задач шаги можно брать больше, для сложных меньше.

### Минусы
1. Справедливости ради, мелкими шажками проще заставить работать и довольно кривой код с запутанной логикой.
2. Когда тесты и код пишутся поочередно, существует возможность неосознанного подгона реализации под частный случай конкретного теста. Да, фаззинг должен помочь, но при первичных прогонах он ведь не делается -- наша задача ведь отсечь заведомо нерабочие схемы. 
### Плюсы
1. Дробление шага снижает когнитивную нагрузку, разгружает "оперативную память" в мозгу.
2. Сильно медленнее копится легаси. Весь или почти весь создаваемый код покрывается тестами, не откладывая на потом.
3. Это есть не что иное, как непрерывное тестирование и интеграция.
### Выводы
1. При плохом проектировании непрерывная интеграция и тестирование тоже будут работать плохо, но не их вина.
2. В повседневной работе, конечно, я все равно в первую очередь изучу код / полезу в отладчик при непройденных тестах. Но тут главное, чтобы это заняло мало времени. Если отладка занимает больше, условно, 15 минут, стоит откатить изменения и переписать код.
