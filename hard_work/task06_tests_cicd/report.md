### Общее впечатление
Задание далось почему-то с сильным скрипом (праздники ?:), я никак не мог взять в толк, как это -- удалять нерабочий код, если он не прошел тест. Тем не менее, разобрался.
Немного похоже на метод решения сложных задач по математике: если не получается с наскока решить в общем виде, то постепенно подбираемся, рассматриваем простые случаи, ищем закономерности, потом обобщаем.

1. Когда пишем новый код, можно коммитить раз в день или раз в один модуль -- выбираем сами "шаг", по настроению и сложности и квалификации
2. Когда правим код от которого зависят другие модули, коммитим малейшие изменения при пройденных тестах
3. Минимальным шагом может быть
	1. логический блок большой функции / метода (тогда тесты могут проверять промежуточные состояния вычисления, которые временно делаются возвращаемыми)
	2. функция / метод
	3. класс целиком
	4. модуль целиком
4. Выбираем минимальный шаг исходя из квалификации и особенностей мышления конкретного программиста, субъективных ощущений -- идет/не идет. Для простых задач шаги можно брать больше, для сложных меньше.

### Минусы
1. Справедливости ради, мелкими шажками проще заставить работать и довольно кривой код с запутанной логикой.
2. Когда тесты и код пишутся поочередно, существует возможность неосознанного подгона реализации под частный случай конкретного теста. Да, фаззинг должен помочь, но при первичных прогонах он ведь не делается -- наша задача ведь отсечь заведомо нерабочие схемы. 
### Плюсы
1. Дробление шага снижает когнитивную нагрузку, разгружает "оперативную память" в мозгу.
2. Сильно медленнее копится легаси. Весь или почти весь создаваемый код покрывается тестами, не откладывая на потом.
3. Это есть не что иное, как практическая часть непрерывного тестирования и интеграции.
4. Особенно удобно для функций, где есть множественный / табличный выбор -- проверять пункты по одному на каждый случай
5. Сильно сокращается время на отладку
### Выводы
1. При плохом проектировании непрерывная интеграция и тестирование тоже будут работать плохо, но не их вина.
2. В повседневной работе, конечно, я все равно в первую очередь изучу код / полезу в отладчик при непройденных тестах. Но тут главное, чтобы это заняло мало времени. Если отладка занимает больше, условно, 15 минут, стоит откатить изменения и переписать код.

### Файлы: 
- класс геом. графа (точки + граф) [geomgraph.py](geomgraph.py)
- тесты к нему [test_geom_graph.py](test_geom_graph.py)
- вспомогательные классы для алгоритма "умной змейки", которая учитывает отверстия в полигоне: набор растров, "гребень" из параллельных прямых (Comb) и другие [snake_smart.py](snake_smart.py)
- тесты к нему [test_snake_smart.py](test_snake_smart.py) 
