**Абстрагирование**

Из практики (было давно)

1. Сначала был создан класс точек, включающий 2 деревьев поиска (одно по id, другое по самой точке) -- запросы на поиск, удаление и добавление выполнялись за O(logN). Он был полностью "замоноличен" и казалось, что это окончательная версия.

2. Потом добавилось требование находить ближайшую точку. Соответствующий метод добавить было можно -- но только полным перебором. Для быстрого поиска было написано kd-дерево. Делать наследника от предыдущего дерева, включая kd-дерево уже "третьим" -- слишком громоздко (хотя бы потому, что быстрый поиск ближайшего так же быстро будет проверять наличие).

3. Поэтому пришлось выпилить одно BST-дерево и добавить kd-дерево.

4. А потом я прошел АСД, поподробнее познакомился с хеш-таблицами, и вместо дерева поиска по id сделал обычный словарь. Получается, что на каждую задачу имеется уже 2 реализации. Активно менять реализации никто не будет, но статически -- нужна вариабельность под разную геометрию. 

5. Поэтому был создан АТД Points с тремя методами find, add, remove, и nearest. А далее уже потомки содержали конкретные реализации.


**Факторизация**

- В программе все, что рисуется в сцене, имеет свою систему координат. 
- Значит, независимо от природы объекта в сцене, он должен иметь свою матрицу трансформации.
- Соответственно, можно задать класс Transformable (при этом добавить проверку на ограничения, например, если нельзя вращать) и унаследовать от него и камеру, и Меши, и Статичные меши, и двумерные объекты...
